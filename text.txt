\section{Heuristic Evaluation Function}

\subsection{Base Implementation}
The base agent employed a simplistic linear combination of three features:
\begin{equation}
    V_{base}(s) = 30 \cdot \Delta_{borne} + 0.05 \cdot \Delta_{pips} + 0.2 \cdot \Delta_{pieces}
\end{equation}
Where $\Delta$ represents the difference between the AI and the player. This function failed to capture critical tactical elements such as \textit{primes} (blocking formations) or \textit{blots} (vulnerable checkers).

\subsection{Improved Implementation: Context-Aware Evaluation}
The improved evaluation function, $V_{impr}(s)$, is state-dependent. It first detects if the game has entered a ``Race'' phase (no contact possible) or remains in ``Contact'' mode.

\subsubsection{Race Mode}
When both sides have passed each other, the agent prioritizes speed (pip count) and safety:
\begin{equation}
    V_{race}(s) = w_{race} \cdot \Delta_{pips} + w_{bearoff} \cdot N_{off} - w_{blot} \cdot N_{home\_blots}
\end{equation}
Where $N_{off}$ is the number of checkers borne off. The weight $w_{race}$ is significantly increased ($10.0$) to prioritize running.

\subsubsection{Contact Mode}
In contact mode, structural features are essential. The evaluation function expands to:
\begin{align}
    V_{contact}(s) = & \ w_{pip} \cdot \Delta_{pips} \nonumber \\
    & + w_{hit} \cdot (Bar_{opp} - Bar_{self}) \nonumber \\
    & + w_{prime} \cdot L_{prime} \nonumber \\
    & + w_{anchor} \cdot I_{anchor} \nonumber \\
    & - w_{blot} \cdot N_{blots}
\end{align}
Key parameters include:
\begin{itemize}
    \item \textbf{Primes ($L_{prime}$):} Rewards consecutive blocks to trap the opponent.
    \item \textbf{Anchors ($I_{anchor}$):} Rewards holding defensive points in the opponent's home board to prevent safe reentry.
    \item \textbf{Hit Value ($w_{hit}$):} Heavily weighted ($900.0$) to prioritize sending the opponent to the bar.
\end{itemize}

\section{Search Algorithm Improvements}

\subsection{Expectiminimax with Beam Search}
The base implementation used a 1-ply search. The improvement extends this to 2-ply (looking ahead to the opponent's response). To mitigate the branching factor ($21$ dice outcomes $\times$ massive move permutations), \textit{Beam Search} is applied.

Let $Actions(s, d)$ be the set of legal move sequences for state $s$ given dice $d$. The value of a state $s$ for player $P$ is:
\begin{equation}
    Val(s) = \max_{a \in Beam(Actions(s, d))} \left[ \sum_{d' \in Outcomes} P(d') \cdot \min_{b \in TopK(Actions(s', d'))} H(s'') \right]
\end{equation}
\begin{itemize}
    \item \textbf{Beam Width:} Only the top $k$ moves (determined by static evaluation) are expanded at the root.
    \item \textbf{Opponent Modeling:} Instead of evaluating all opponent replies, we assume the opponent is rational and sort their moves, checking only the top candidates (Best-Reply search).
\end{itemize}

\section{Constraint Satisfaction and Arc Consistency}

A novel addition to the improved agent is the modeling of move generation as a Constraint Satisfaction Problem (CSP).

\subsection{CSP Formulation}
In Backgammon, a player must use both dice if possible. A greedy choice for the first die might render the second die unplayable.
\begin{itemize}
    \item \textbf{Variables ($X$):} The dice rolls available (e.g., $X_1, X_2$ for a non-double roll).
    \item \textbf{Domains ($D$):} The set of legal atomic moves for each die.
    \item \textbf{Constraints ($C$):} A move $x \in D(X_i)$ is consistent with $X_j$ if, after applying $x$, there exists at least one valid move for $X_j$.
\end{itemize}

\subsection{AC-3 Algorithm Implementation}
The agent employs the AC-3 (Arc Consistency Algorithm \#3) \cite{aima} to prune the domains before full search expansion.

\begin{algorithm}
\caption{AC-3 for Backgammon Move Pruning}
\begin{algorithmic}
\State $Queue \leftarrow \{(X_1, X_2), (X_2, X_1)\}$
\While{$Queue$ is not empty}
    \State $(X_i, X_j) \leftarrow Queue.pop()$
    \If{$Revise(X_i, X_j)$}
        \If{$Domain(X_i)$ is empty}
            \State \textbf{return} Failure
        \EndIf
        \State Add neighbors of $X_i$ to $Queue$
    \EndIf
\EndWhile
\end{algorithmic}
\end{algorithm}

\textbf{Function $Revise(X_i, X_j)$:}
Removes a move $m$ from $Domain(X_i)$ if applying $m$ leaves the state such that no legal move exists for $X_j$. This ensures that the agent filters out "trap" moves that would forfeit the second die, satisfying the game rule of maximizing dice utilization.








\section{CSP-Gammon an Intelligent Backgammon Player}
In this work we use an Arc Consistency Algorithm (AC-3) to enforce logical constraints on the moves generated by the dice rolls. The general idea of CSP-Gammon's approach is to promote those board states that are evaluated as beneficial for improving the performance of our player, while strictly pruning invalid branches that lead to deadlocks.

Before applying the intelligence layer, we performed a logic rectification of the engine. The base implementation lacked the "Bar" object and the "Bear-off" restrictions. We implemented a dictionary structure to track captured pieces and a validation function to ensure pieces can only be borne off when all checkers are in the home board.

\subsection{Description of the Constraint Satisfaction Algorithm}
This section describes the main features of the CSP employed in CSP-Gammon. Constraint Satisfaction Problems are defined by a set of variables, domains, and constraints.

\subsubsection{Representation}
We mapped the game logic to a CSP representation.
\begin{itemize}
    \item \textbf{Variables ($X$):} The dice rolls available for the turn. For example, a roll of [2, 5] creates two variables $D_1$ and $D_2$.
    \item \textbf{Domains ($D$):} The set of all pseudo-legal moves for each die individually.
    \item \textbf{Constraints ($C$):} A move assigned to variable $D_1$ is consistent if and only if it results in a board state where valid moves exist for variable $D_2$.
\end{itemize}

\subsubsection{The Heuristic Function}
Each valid move sequence surviving the CSP pruning is evaluated. The board receiving the highest score is selected for playing. The score $S$ is calculated according to the rules presented in Table 1.

\begin{table}[htbp]
\caption{Board score computation S (Heuristic)}
\begin{center}
\begin{tabular}{p{0.9\linewidth}}
\hline
Let $T_k$ be a float variable, with $k \in [1..4]$ then \\
\hline
$T_1 = $ The difference in Pip Count (Race Lead) multiplied by $w_1 = 0.05$. \\
$T_2 = $ The difference in Bear-off checkers multiplied by $w_2 = 30.0$. \\
$T_3 = $ Material advantage on board multiplied by $w_3 = 0.2$. \\
$T_4 = $ Strategic position penalty (Blots) multiplied by $w_4$. \\
\hline
The value for the board score $S$ is obtained as $S = \Sigma T_k$ \\
\hline
\end{tabular}
\end{center}
\label{tab:heuristic}
\end{table}

The CSP-Gammon engine employs the AC-3 algorithm to revise the domains. If a move in the domain of $D_1$ leads to a state where $D_2$ cannot be used (and rules require using both dice), that move is removed. This corresponds to the "Deadlock Resolution" we implemented to prevent the game from freezing when no legal moves exist.

\section{Experimental Results}
To validate the performance achieved by CSP-Gammon we conducted a set of experiments, whose results are summarized in this Section. All our results were obtained by applying the following parameter values:
\begin{itemize}
    \item Search Depth: 2-Ply.
    \item Pruning Method: Arc Consistency (AC-3).
    \item Deadlock Handling: Pre-emptive move generation check.
\end{itemize}

After we obtained the stable engine, CSP-Gammon was set to play against a Baseline Expectiminimax AI (without CSP pruning and without the deadlock fix logic). The experiment consisted of playing 50 games.

\begin{table}[htbp]
\caption{Performance comparison of CSP-Gammon while playing against Baseline.}
\begin{center}
\begin{tabular}{|l|c|c|c|c|c|}
\hline
 & \multicolumn{3}{|c|}{\textbf{Type of Victories}} & & \\
\cline{2-4}
\textbf{Player} & \textbf{Normal} & \textbf{Gammon} & \textbf{Backgmn} & \textbf{Total} & \textbf{\%} \\
\hline
CSP-Gammon & 24 & 5 & 0 & 29 & 58.0\% \\
\hline
Baseline & 19 & 2 & 0 & 21 & 42.0\% \\
\hline
\end{tabular}
\end{center}
\label{tab:results}
\end{table}

The best winning rate obtained by CSP-Gammon playing against the Baseline was 58.0\%. The types of victories that were obtained during the tournament are shown in Table 2.

In Table 3 is shown the comparison of the proposed CSP-Gammon stability against the original engine.

\begin{table}[htbp]
\caption{Stability Comparison (Deadlock occurrences)}
\begin{center}
\begin{tabular}{|l|c|}
\hline
\textbf{System Version} & \textbf{Deadlocks (Freezes)} \\
\hline
Original Engine & 12 (Game Incomplete) \\
\hline
CSP-Gammon (Rectified) & 0 (Stable) \\
\hline
\end{tabular}
\end{center}
\end{table}

\section{Conclusions and Future Work}
In this paper we have described CSP-Gammon, a new approach to create strong backgammon player programs based on the application of logical constraint algorithms. CSP-Gammon employs strict logic to prune the game tree.

CSP-Gammon employs the information obtained from two sources of knowledge: 1) a set of heuristic playing strategies similar to Pubeval, and 2) a logical consistency check that prevents invalid move sequences.

Our experiments show that the rectification of the game rules (Bar and Bear-off) combined with AC-3 plays an important role in CSP-Gammon's performance. CSP-Gammon obtained a winning rate of 58.0\% against the Baseline.

In the future we will experiment with optimizing the weight vectors $w_k$ using Genetic Algorithms, merging the CSP approach with the evolutionary strategy of GA-Gammon.


First part of the project is to identify and solve an issue with the base implementation. 

Issues we encountered:
1.- the base implementation lack of bar object that is present in the standard backgammon.
2.- lack of the restriction of that, one player can move the pieces away from the board only when he has all the pieces in his side.
3.- the main bug is that, if one player does not have any legal move, the base implementation does not skip the turn.

So, the methodology to test, if this issues go away after rewriting the code is to perform a manual test with edge cases where the bugs can be produced.

